> 翻译：[Neil-xiang](https://github.com/Neil-xiang)
> 校对：

##硬件支持(Hardware Support)
	Android的硬件支持方法与通常在Linux内核中或基于Linux的发行版中发现的经典方法截然不同。具体来说，建立在该硬件支持上的抽象以及围绕许可和分发结果代码的思维方式上实现硬件支持的方式都是
不同的。

##Linux的方法(The Linux Approach)
	在Linux中创建一个设备驱动来支持一个新的硬件的常用方法是作为内核的一部分编译或者是在模块运行的过程中动态的加载。此后，相应的硬件可以通过在/dev中的入口在用户空间访问。Linux的驱动模型
通常被定义为3种常见的设备:字符设备(通常被当作数据流设备)、批量存储设备(比如硬盘)、网络设备。多年来，只有极少的几个外设和子系统设备被添加，比如USB或者存储技术设备(Memory Technology D-
evice(MTD))。然而，与对应于给定类型设备，通过/dev目录入口的API和方法保持相当标准化和稳定。
	这允许在/dev节点之上构建各种软件堆栈，以直接与硬件交互，或者用户应用程序使用通用API来提供对硬件的访问。绝大多数Linux发行版实际上都带有一组类似的核心库和子系统，如ALSA音频库和 X窗口
系统(X Windows System),通过/dev来与硬件设备进行交互。
	至于许可和发行，一般的“Linux”方法一直是驱动程序作为主线内核的一部分被合并和维护，并根据GPL的条款发行。所以，有些设备驱动被独立的开发和维护并在其他的许可下发行，但大家认为这不是首选
的方法。实际上，关于许可证，非GPL驱动程序一直是一个有争议的问题。所以，用户和经销商对获取最新驱动程序的最佳选择通常是从http://kernel.org获取最新的主线内核。从内核的早期开始就一直是这
样的，尽管还有一些内核被添加到内核以允许创建用户空间的驱动程序

##Android的常用方法(Android’s General Approach)
	虽然Android基于内核的硬件抽象和功能，但其方法却截然不同。从纯技术上来讲，最明显的区别是它的子系统和库文件并不完全依赖于标准的/dev入口功能。相反的，Android的栈通常是依赖于制造商提供
的共享库来与硬件交互。实际上，Android依赖于被称为硬件抽象层(Hardware Abstraction Layer(HAL))的东西,尽管我们将看到抽象硬件组件的接口、行为、功能根据不同的类型有很大不同。
	另外，在Liunx发布版本中通常能找到的与硬件交互的大部分软件堆栈在Android中找不到。例如，没有X Window系统(X Windows System),当有时为HAL提供audio共享库支持的硬件制造商使用ALSA驱动来实现
功能时与标准的发行版Linux有区别。例如，ALSA(Advanced Linux Sound Architectur)库通常作为Linux笔记本环境下ALSA驱动的接口，但是在AOSP的官方库中并没有使用。在最新的Android发布版本中使用BSD
开源协议的tinyalsa库来替代它。
	图2-3介绍了典型的在Android中支持的被抽象的硬件，以及相对应的分布及授权。就像你看到的一样，Android仍然从根本上依赖与内核来和硬件交互。然而，这个却是通过由设备制造商提供或作为AOSP的一
部分的共享库来实现的。通常来说，你可以将HAL层视为图中显示的硬件库的装载器，以及定义的各种硬件类型的头文件，这些相同的头文件被API使用相同类型的.so库文件定义。
	这种方法的主要特征之一是共享库分发的授权取决于硬件制造商。因此，设备制造商可以创建一个简单的设备驱动，实现最基本的访问给定的硬件的操作，并使该驱动可用于GPL协议。对硬件来说没有太多可以
揭露的，因为驱动不会做太多花哨的事情。驱动可能在用户空间通过mmap()或者ioctl()来和硬件交互，大量对设备硬件的复杂操作在用户空间内专有的共享库里执行。
	Android实际上没有详细的说明共享库如何与驱动或内核子系统进行交互。由共享库提供给上层的API仅由HAL指定。因此，由你来决定最适合你硬件的特定驱动程序接口，只要你提供的共享库实现相应的API。
然而，我们将在下一节中介绍Android所使用的与硬件进行结合的典型方法。
	Android相对不一致的地方是硬件支持的共享库是由上层加载的。记住，目前对大多数的硬件类型，都一定要有一个由AOSP或你提供的一个.so文件，Android才能正常运行。
	无论加载硬件支持共享库的机制是哪一种，对应于硬件类型的系统服务通常负责加载和与共享库进行交互。那个系统服务将负责和其他的系统服务进行交互协调，以使硬件表现得和其余的系统及API对于app开发
人员来说表现得一致。如果你要添加一个给定类型的支持，你必须尽可能详细地了解与你的硬件对应的系统服务的内部部分。通常，系统服务被分成两部分:第一部分是java来实现大部分Android特定的复杂功能；
另一部分是c/c++部分，主要工作是与HAL、硬件支持的共享库和其他的底层函数进行交互。

##加载及交互方法(Loading and Interfacing Methods)
	正如我之前提到的那样，系统服务和Android有多种方法来和硬件支持的共享库及硬件设备进行交互。想要完全的理解为什么有这么多的方法是很困难的，但我怀疑他们中的某些是系统的发展的。幸运的是，似乎
有一个发展方向是在向着统一的做事方式。鉴于Android发展的速度相当快，这在可预见的未来是一个值得关注的领域，它很有可能会进化。
	请注意，这里描述的方法不一定是相互排斥的。通常这些方法的组合在Android的堆栈内部使用来装载和与共享库交互，或者它之前或之后的软件层。接下来的章节我将具体的介绍硬件。
	
	*dlopen()-通过HAL装载(loading through HAL)
	应用于：GPS, 灯(Lights), 传感器(Sensors),和显示器(Display). 从Android4.0后也提供给Audio和Camera使用。
	一些硬件支持的共享库由'libhardware'库来装载。这个库是Android的HAL的一部分，公开了hw_get_module()。此函数被一些系统服务或者子系统来显示的装载一个指定的硬件支持的共享库(在HAL也被叫做专业
术语‘模块’(module))。hw_get_module()依赖于经典的dlopen()将库加载到调用者的地址空间中。
	**HAL中的‘模块’(module)不要和可加载的内核模块(loadable kernal module)混淆，这是两个完全不同和不相关的软件构造，尽管它们具有一些类似的属性。
	
	*链接器加载的.so文件(Linker-loaded .so file)
	应用与: Audio, Camera, Wifi, 震动器(Vibrator), and Power Management
	在某些情况下，系统服务在构建时只能与给定的.so文件链接。因此，当运行相应的二进制文件时，动态链接器会自动将共享库加载到进程的地址空间中。
	
	*硬编码的dlopen()(Hardcoded dlopen())
	应用于: StageFright 和无线接口层 (Radio Interface Layer (RIL))
	在少数情况下，代码直接调用dlopen()而不是通过libhardware来获取启用硬件的共享库.使用这种方法而不是HAL的理由尚不清楚。
	
	*端口(Sockets)
	应用于: Bluetooth, Network Management, 硬盘加载(Disk Mounting), and Radio Interface Layer (RIL)
	端口通常被系统服务或者框架组件用来与实际同硬件进行交互的远程后台进程或者服务进行交流。
	
	*sysfs文件系统目录(sysfs entries)
	应用于: 震动器(Vibrator) and Power Management
	sysfs(/sys)文件系统中的一些条目可以用来控制硬件和/或内核子系统的一些行为。在某些情况下，Android使用这种方法代替/dev 条目来控制硬件。使用sysfs条目代替/ dev节点是有道理的，例如，当框架的任
何部分尚未运行，而系统初始化期间需要设置缺省值时。

	*dev节点(/dev nodes)
	应用于:基本上所有类型的硬件
	可以说，任何硬件抽象必须在某种程度上与/ dev中的条目进行通信，因为这是驱动提供给用户空间的。其中一些通信可能隐藏在Android本身，因为它与共享库交互，但是在某些个别案例中，AOSP组件直接与设备
节点通信。比如输入管理器使用的输入库就是这种情况。

	*D总线(D-Bus)
	应用于：蓝牙(Bluetooth)
	D-Bus是大多数Linux发行版中发现的一种经典消息系统，用于促进各种桌面组件之间的通信。它在Android中的原因是因为它是非GPL组件与GPL授权的BlueZ堆栈进行通信的指定方法而不受GPL再分配协议的约束，而
BlueZ堆栈是Linux默认的蓝牙堆栈并且Android中也在使用。D-Bus本身根据学术免费许可证（AFL）和GPL双重许可。有关更多信息，请查看freedesktop.org(http://dbus.freedesktop.org/)的D-Bus页面.
	鉴于BlueZ已经从Android4.2/Jelly Bean开始从AOSP中删除，目前尚不清楚D-Bus在将来的Android版本中将会是什么样(如果有的话)。
	
	*设备支持详情(Device Support Details)
	表2-1总结了Android中支持每种类型的硬件的方式。你会注意到，机制和接口的组合有很多种。如果你计划实施对特定类型硬件的支持，最好的方法是从现有的示例实现开始。AOSP通常包括几个手机的硬件支持代码，
通常这些代码由Google用于开发新的Android版本，因此可以用作引导设备。有时硬件支持的来源相当广泛，就像三星Nexus S(其代码名称为'Crespo')在Android2.3(Gingerbread)中而Galaxy Nexus (也被称为“Maguro”) 
和Nexus 7 (也被称为“Grouper”)在Android4.1/Jelly Bean中的情况一样。
	您不可能找到公开实现的唯一硬件类型是RIL。由于各种原因，最好不要让每个人都能发射无线电波。因此，制造商不会提供这样的实现。相反，如果您想实现一个RIL，Google将在AOSP中提供参考RIL实现。
	
	Table2-1 Android的硬件支持方法和接口
	