> 翻译：[Neil-xiang](https://github.com/Neil-xiang)
> 校对：

###本地用户空间(Native User-Space)
	现在我们已经介绍了构建Android的低层次图层，现在让我们开始堆栈。首先，我们将介绍Android运行的本地用户空间环境。通过“本机用户空间”，我的意思是在Dalvik虚拟机之外运行的所有用户空间组件。
这包括了相当多的二进制文件，被编译为在目标CPU架构上本地运行。这些通常根据其配置文件自动启动或根据init进程的需要启动，或者一旦开发人员进入设备，就可以从命令行调用。这样的二进制文件通常
可以直接访问系统中包含的根文件系统和本地库文件。它们的功能仅受到授予他们文件系统的权限及其有效的UID和GID的限制。由于Android Framework正在其外部运行，因此Android 应用不会受到任何限制。
	
	请注意，Android的用户空间从空白状态而来，与标准Linux发行版中的用户空间大不相同。因此，我将尽可能地尝试解释Android的用户空间与在Linux系统中通常会发现的不同之处。
	
	##文件系统分布
	和任何其他基于Linux的发行版一样，Android使用根文件系统来存储应用程序，库和数据。然而，与绝大多数基于Linux的发行版不同，Android根文件系统的布局不符合 文件系统层次标准(Filesystem 
Hierarchy Standard(FHS))。内核本身不执行FHS,但是为Linux构建的大多数软件包假定它们正在运行的根文件系统符合FHS。因此，如果您打算将标准的Linux应用程序移植到Android。您可能需要采取一些措施
来确保其依赖的文件路径仍然有效。或使用某种形式的“chroot jail”将其和支持包与其他根文件系统隔离开来。(有关详细信息，请参阅chroot的手册页)。
	鉴于Android的用户空间中运行的大多数软件包是从头开始专门为Android编写的，这种缺乏一致性对Android本身来说倒无关紧要。事实上，它有一些好处，我们稍后会看到。不过，了解如何浏览Android根文
件系统很重要。如果没有别的东西，你就需要花费大量的时间将Android移植到你的硬件上或者为你的硬件定制一个。
	Android操作的两个主要目录是/system和/data。这些目录不是由FHS产生的。事实上，我想不出任何一个主流的Linux发行版本使用了这些目录中的任何一个。相反，它们反映了Android开发团队自己的设计。
这是一个迹象，暗示在同一个根文件系统下同时运行通用的Linux发行版本和Android是可能的。查看附录A了解如何创建这样一个混合体的更多信息。
	/system是用来存储由AOSP构建生成的不可变组件的主要Android目录。这包括本地二进制文件，本机库文件，框架包和应用程序固件。它通常从根文件系统中一个独立的镜像挂载为只读，而根文件系统是从RAM
硬盘镜像挂载。另一方面，/data是Android的主要目录，用于存储随时间变化的数据和应用程序。这包括由用户安装的应用程序生成和存储的数据，以及运行时由Android系统组件生成的数据。虽然以读写模式挂
载，但是它通常是从其独立的镜像安装。
	Android还包括通常在任何Linux系统中找到的许多目录，比如/dev、/proc、/sys、/sbin、/root、/mnt、/etc。这些目录通常与其在任何Linux系统上提供的目录相似但不相同，尽管它们经常被修剪，如/sbin
和/etc的情况，在某些情况下为空，如/root
	有趣的是，Android不包含任何/bin或/lib目录。这些目录在Linux系统中通常至关重要，分别包含必要的二进制文件和必要的库文件。这是另一个让Android与标准Linux组件共存的大门。
	当然还有更多关于Android根文件系统内容。例如，刚才提到的目录包含它们自己的层次结构。此外，Android的根文件系统包含其他这里没有介绍的目录。我们将在第6章详细的介绍Android根文件系统及其组成

	##库文件(Libraries)
	Android依赖于大约100个动态加载的库，全部存放在/system/lib目录中。一定数量的外部项目被合并到Android的代码库，以便在Android堆栈中提供其功能，但是/system/lib中的大部分库实际上是从AOSP本身
内生成的。表2-2类出了包含在AOSP中来源于外部项目的库，表2-3总结了在AOSP内部产生的Android特定的库。
	自从Android2.3/Gingerbread以来，许多库已经被添加到AOSP中。表2-4和2-5列出了你在4.1/Jelly Bean中找到的一些最显着的添加内容。
	
	##初始化(Init)
	Android不会改变的一件事就是内核启动过程.因此，你对Linux内核的启动过程了解的内容一样适用于Android。Android中发生的变化都是在内核启动完成后发生的。事实上，在初始化完自己及包含的驱动后，内核
内核只启动一个用户空间进程，初始化(init)进程。然后，该进程负责产生系统中的所有其他进程和服务，并进行关键操作，如重新启动。习惯上来说，尽管近年来许多发行版已经创造了自己的变种，但是Linux发行
版本仍依赖于SystemV init用于init进程。例如，Ubuntu使用Upstart。 在嵌入式Linux系统中，提供init的经典软件包是BusyBox。
	Android引入了自己的自定义init，它带来了一些新事物。
	
	#配置语言(Configuration language)
	与使用根据当前运行级配置或请求运行脚本的传统初始化不同，Android的init定义了自己的配置语义，并依赖于对全局属性的更改来触发特定指令的执行。
	init的主要配置文件通常存储为/init.rc，但是也通常存在特定设备的配置文件存储为/init.<device_name>.rc。其中<device_name>是设备的名称。特别的，比如说模拟器/仿真器，同样有一个特定设备的脚本文件
存储为/system/etc/init.<device_name>.sh。你可以通过修改这些文件来高度控制系统的启动及其行为。比如，你可以禁止掉Zygote自动启动，然后在使用adb进入设备后手动启动。Zygote是一个关键的系统组件我们
将在本章后面及第7章更详细地介绍。
	我们将在第6章中深入讨论初始配置语言。
	
	#全局属性(Global properties)
	Android的init的一个非常有趣的方面是它如何管理全局的属性集，可以从系统的许多部分访问和设置相应的权限。这些属性中的一些在构建时设置，而其他属性在init的配置文件中设置，还有一些在运行时设置。一
些属性也被永远存储以供持续使用。由于init管理着属性，它可以检测任何更改，从而根据其配置触发一组命令的执行。
	例如，前面提到的OOM调整在init.rc文件启动时设置。网络属性也是如此。在构建时设置的一些属性存储在/system/build.prop文件中，并包含构建日期和构建系统详细信息。在运行时，系统将具有超过100种不同的
属性，从IP和GSM配置参数到电池电量。使用‘getprop’命令获取当前的属性列表及其值。
	我们将在第6章中更详细地讨论init的全局属性，用于提供其默认值的文件以及相关命令。
	
	#udev事件(udev events)
	如前所述，在Linux中通过/dev目录中的节点访问设备。在过去，Linux发行版在这个目录中附带数千个条目，以容纳所有可能的设备配置。最终提出了一些方案来动态的调整这些节点。现在系统使用‘udev’已经有一段
时间了，‘udev‘依赖于每次从系统中添加或删除硬件时内核生成的运行时(runtime event)事件。
	在大部分的Linux发布版本中，udev的热拔插事件由’udev‘后台程序来处理。在Android中，这类事件由构建为Android初始化的一部分的’ueventd‘后台程序来处理的，并通过/sbin/ueventd到/init的符号连接访问。为
了知道在/dev中创建了那些条目，’ueventd'依赖于/ueventd.rc和/ueventd.<device_name>.rc文件。
	我们将在第6章中详细讨论ueventd及其配置文件。
	
	##工具箱(Toolbox)
	很像根文件系统的目录层次结构一样，大多数Linux系统都有基本的二进制文件，由FHS文件系统在/bin和/sbin目录下列出来。在大部分的Linux发布版本中，在这些目录下的文件都是来源于网络上的独立的项目编译来的。
在一个嵌入式系统中，没有道理处理这么多的软件包，也没有必要需要那么多的二进制文件。
	经典BusyBox软件包采用的方法是构建一个单一的二进制文件，它基本上具有相当大的开关量(switch-case)，它检查命令行上的第一个参数并执行相应的功能。然后所有命令和'busybox'命令建立一个符号连接。所以比如
你输入'ls'，你实际上调用的BusyBox。但是由于BusyBox的行为是基于命令行上的第一个参数，该参数是ls，它将表现为从标准Linux shell运行该命令一样。
	Android不使用BusyBox，而是包含自己的工具Toolbox，它基本上以相同的方式运行，使用‘toolbox’命令进行符号连接。然而工具箱不如BusyBox的功能丰富。事实上，只要你以前使用过BusyBox，你在使用ToolBox时很可
能会感到失望。在这种情况下从头开始创建工具的理由似乎是授权角度，BusyBox是GPL许可的。此外，一些Android开发人员表示，他们的目标是为基于shell的调试创建一个最小的工具，而不是完全代替诸如BusyBox之类的
shell工具。无论如何，Toolbox是BSD许可的，因此制造商可以对其进行修改并发布，而无需跟踪开发人员所做的修改或向其客户提供任何来源。
	您可能还希望将BusyBox与ToolBox包含在一起来实现功能。如果由于授权的原因，你并不像将它作为你最终产品的一部分，您可以在开发过程中暂时包含它，并将其从最终的生产版本中删除。我将在附录A中详细介绍。
	
	##后台进程(Daemons)
	作为系统启动的一部分，Android的init启动了在系统的整个生命周期中持续运行的几个关键后台进程。一些后台进程（如adbd）根据构建选项和全局属性的更改按需启动。表2-6提供了Android运行的一些更显著的后台
程序的列表。其中许多在第6章和第7章中进行了更为详细的讨论。
	*Table2-6.Android的后台进程
	
	##命令行工具(Command-Line Utilities)
	超过150个命令行实用程序分散在Android的根文件系统中。/system/bin包含它们中的大多数，但是一些“附加”(extras)的在/system/xbin中，还有一小撮在/sbin中。/system/bin中的大约50个实际上是/system/bin/toolbox
的符号连接。其余大部分来自Android基础框架，从外部项目融入AOSP或来自AOSP的其他各个部分。我们将有机会在第6章和第7章中更详细地介绍AOSP中发现的各种二进制文件。
	