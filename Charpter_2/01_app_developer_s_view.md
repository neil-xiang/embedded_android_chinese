> 翻译：[koffuxu](https://github.com/koffuxu)
> 校对：

# 应用开发者观点

鉴于Android开发API不同于其它已经存在的API，包含其它在Linux世界的事，这是非常重要的，发一点时间从应用开发者的角度来理解“Android”看起来是什么，就算是一个研究过AOSP的人来说，这都不是一件容易的事。作为一个以Android为系统的嵌入式设备的开发者，你也许没有理解Android的应用开发API的特质，但是你也许有同事了解。如果也没有，你不妨与应用开发者分享一些共同的信息。当然，这部分是简单的一个总要，我建议你读一些Android应用开发去获得一些更深的部分。

##Android 概念

作为一个应用开发者，当开发Android应用时，需要把一些关键的概念弄清楚。这些概念能构建整个Android应用的架构，以及开发者可以或者不可以的指令。
总之，他使用户的生活更好，但要处理好也是有挑战的。

###组件

Android应用是一些松耦合的*组件*构成。一个应用的组件可以被其它应用调用或者使用。最重要的是，Android App没有一个单独的入口函数：也就是说没有main()或者其它类似的函数。
相反，一些被*intents(意图)*预定义的事件，开发者可以把自已的组件挂在上面，从而，在相应的事件发生，就会调用定义的组件。
一个简单的例子，组件处理用户通信录数据库，当用户在拨号或者其它APP按一个联系人按钮时，这就会被调用。因此，一个app根据它所有的组件会有多个入口。

这里有4大组件：

*Activity*

就像一个“窗口”，是基于GUI系统，构建了主要的交互窗口，activities组成了Android app主要的构架。跟窗口不一样的是，activities不能被 最大化，最小化，和调整大小。
相反地，activities总是占据了整个可视区域用来堆叠彼此。同样的，浏览器的网页以一定的序列来访问，允许用户使用“后退”来浏览之前的内容。
事实上，在前几章的描述中，所有Android设备必须有“后退”键让用户回到前一个行为。与网页浏览不同的是，这没有类似网页“前进”的按键，也许只有“后退”。

一个全局的Android intent允许一个activity以一个图标的形式显示在app Launcher(主要app list)，因为许多重要的app想要在Launcher上，它们至少一个activity能够影响这个intent。通常，用户从一个特定的activity到结束，会创建一个堆栈，所有相关的他们最初起动；这个应用的堆栈就是*task*。用户可以通过HOME按键切换到另外一个任务，从Launcher启动另外一个应用堆栈。

*services*

Android services类似于Unix系统的后台进程或者是守护进程。本质上，一个service被激活是在其它组件请求这个服务，服务就通过这个调用者激活了。
最重要的是，服务可以提供外部应用程序组件，因此，显露一些应用程序的核心功能给其它应用程序。一个服务被激活使用通常没有一个可视的界面。

*Broadcast Receivers*

广播接收器类似一个中断处理句柄。当一个关键的事件发生，一个广播接收器将会被触发去处理这个事件。比如，一个应用程序当电量较低的时候被提醒，或者当是“飞行模式”被激活的时候。
当它们已经注册的事件没有发生，广播接收器将不会被激活。

*Content Providers*
内容提交者本质是一个数据库。通常，如果一个应用想提供其它应用程序访问的数据就需要一个内容提交者。比如，你编译一个Twitter客户端，你将要提供给其它应用访问Twitter的内容。
所有的content prividers提供同校报API，不管你怎么实现你的内部。在Android，许多Content Provider依赖SQLite数据库的功能，但同样可以使用文件或者其它存储类型。

##意图

意图Intent是Andoird非常重要的概念之一。它是一种在各组件之后延迟绑定（late-binding）机制。应用开发者可以从一个应用发送意图给“浏览”一个网页或者“浏览”一个PDF，
因此，用户就可以浏览目标HTML或者PDF文档，尽管这个请求的APK没有包含这些内容。使用意图的更多乐趣也是可能的。应用开发者可以发送一个指定的意思去触发一个电话括号。

考虑到意图作为一种多态的Unix信号，没有必要预定义或者请求一个指定目的地的组件或者应用程序。意图类似于一个被动的对像。它的内容（负载），这种用于发送的机制与系统的行为规则一致。比如系统规则的一种，意图试图于组件发送。比如，一个意图发送给一个服务，那么只有服务才能收到这个，不是一个Activity或者Broadcast receiver.


组件可以被声明为指定意图的声明，通过manifest文件。在运行时，系统将传输相匹配的意图来触发相应的组件。一个意图同样被一个指定的组件发送，绕过需要声明,在接收组件的意图过滤器。明确的调用，需要应用知道指定的组件的提前时间，在同一个应用组件中想必改善是意图典型的应用。

##组件生命周期

Android另外一个重要的概念，用户不能去管理这任务的切换。因此，Android的是没有任务条以及类似功能的。然而，用户可以打开任意多的应用。通过HOME按键进入Home主界面，然后再选择另外一个应用进入。这个应用也许是一个新的。也许是之前已经打开过，Acitivity Stack（或者说任务）已经存在的。
	这样一个app的设计方案的一个结果就是在开始时就使用越来越多的系统资源，而处理器不能无限制的运行下去。
在某些时候，系统必须开始回收最近很少使用到的或者低优先级的组件，以便为新激活的组件提供资源，同时这个回收资源必须完全对用户是透明的。
换句话说，当一个组件被换下为一个新的组件提供资源时，当用户返回的是最初的组件时，他必须在被换下的地方被激活，就好像这个组件一直在内存中存在一样。
	要实现这样的行为，Android为每个组件定义了一个标准的生命周期(lifecycle)。一个app开发者必须通过实施一系列回调来管理他每个组件的生命周期。这些回调被与组件生命周期相关联的事件触发。
例如当一个Activity不再前台运行(更像是被销毁)，他的回调[on pause()]被触发。Google使用状态图来对App开发者解释Activity的的生命周期。
	管理组件的生命周期是App开发者面临的最大的挑战之一，因为他们在关键的过渡事件中必须非常小心的保存及恢复组件的状态。期望的最后的结果是用户完全不需要再app间进行"任务切换"(task switch)
或者是担心旧的app组件在为新的app腾出空间时被破坏掉。

##清单文件(Manifest file)
	如果一个App必须要有一个main入口，那清单文件就很合适。其本上它表明了APP的系统组件、运行App的性能要求、最小的API层数要求、硬件要求等。
清单文件保存在app的源代码的根目录下，以AndroidManifest.xml命名的XML类型文件。一个App的组件通常都在清单文件中静态描述出来。事实上，除了广播接收器(Broadcast Receivers)可以在运行
过程中被创建外，其他的组件必须在构建的过程中在清单文件中被声明。

##进程和线程(Processes and threads)


	无论App的组件在任何时候无论是被系统还是被其他的App激活，一个进程会被创建来容纳App组件。除非App开发人员覆盖了系统的默认值，否则App的其他所有组件在被激活并初始化后都运行在同一个进程中。
换句话说，一个App的所有组件都包含在了一个Linux的进程中。因此，开发人员应该避免在一个标准的组件中进行长时间或者阻塞操作，这种操作应使用线程来代替。
	因为理论上来说用户可以激活他想要的任何数量的组件，几个Linux的进程通常在任何时候都是活动的已服务包含用户组件的许多App。当有许多的进程在运行时，如果再打开一个进程，Linux内核的
内存溢出(out-of-memory(OOM))停止机制就会生效。在那个时候，Android的内核的内存溢出操作会被调用，并来判断需要杀死某个进程来保证空间。
	简而言之，Android的所有行为都是在低内存的条件下的。	
	如果被Android的内存溢出机制杀死进程的App开发人员能适当的管理他的组件的生命周期，则用户是不会发现有任何异常的现象的。事实上为了实用性的目的，用户实际上都不应该注意到
进程空间被释放并在稍后被自动的重新创建。

##远程调用(Remote procedure calls(RPCs))
	同其他的系统组件一样，Android定义了它自己的PRC/IPC(remote procedure call/inter-process communication)机制:Binder.所以，组件间的通信并不是由通用的端口或者系统的IPC来完成的。
而是组件通过内核的Binder通信机制来实现。参考/dev/binder，会在本章的后续部分介绍。
	然而，App的开发者不直接使用Binder机制，而是必须通过Android 交互定义语言来定义和与界面交互(Android’s Interface Definition Language (IDL))。交互定义通常以.aidl文件存放，
并且通过aidl工具来生成使用Binder机制来回传送对象和数据所需的正确的存根和编组/解编组的代码。

##(框架介绍)Framework Intro
	为了达到我们刚刚讨论的要求，Android定义了它自己的开发框架，允许开发人员得到其他的开发框架一样的体验。我们简单的来看一下Android框架及其功能
	
	**用户界面
	Android用户界面的基本元素包括如按键、文本框、对话框、菜单以及时间处理等传统的控件，这部分API相对简单，如果开发者使用其其他的UI框架的话，通常都能很容易的找到这些控件。
	Android中所有的UI对象都被定义为view类的子类，并被ViewGroup分层管理。一个活动的UI事实上既可以使用XML来静态的描述(这是常用的做法)也可以使用java来动态的声明。如果有需要UI还可以在
java运行的过程中被修改。如果一个UI的组件被设置为ViewGroup层级的顶层时，此UI会被显示。

	**数据存储(Data storge)
	Android为开发者提供多种存储选项。为了满足简单存储需求，Android提供共享参数(Shared preferences)，它允许开发者既可以将密钥对保存在数据中供app中的其他组件来使用也可以保存在一个
特定的独立文件中。开发者还可以直接修改其他的app无访问权限的另一个App的私有文件，或者App设定为只读/只写的文件。App开发者还可以使用Android内部的一个轻量级数据库(SQLite)来管理他
自己的私有数据库。Such a database can then be made available to other apps by hosting it within a content provider component

	**安全及权限管理
	Android中的安全管理运行在进程级。换句话说，Android依靠Linux现有的进程隔离机制来实现自己的策略。为了实现这个目的，每个安装后的App都得到一个自己的UID以及组标识符(GID).本质上来
说，就好像在系统中每一个app都是一个独立的用户(user)。在任何一个多用户的UNIX系统中，除非有明确的授权，每个用户都不能互相访问对方的资源。事实上，每个App都在他独立的沙箱中(sandbox).
	为了退出沙箱并访问关键系统功能或资源，App必须使用Android的权限机制，它要求开发者在app的清单文件(Manifest file)中静态的定义app需要的权限。比如网络(比如使用端口)、拨打电话
或使用摄像头等Android预定义的功能。其他的权限可以由用户声明并通过app的组件来供其他app使用。当一个文件安装好后，用户被提示同意运行app需要的权限。
	访问权限执行基于单进程并要求使用特定的URI(universal resource identifier),并且基于证书及用户提示来决定是否永续访问特定功能或资源。这个证书是app开发人员通过Google Play提供的，用
来签名开发的app。开发人员可以将他们应用程序的功能限制在他们自己以前创建的其他应用程序中。

	Android开发框架提供了大量的功能，当然未完全列举在这里。我建议去读在http://developer.android.com上的其他android app开发的详细资料，包括2D/3D图像处理、多媒体、位置地图、蓝牙、
NFC等。

##App开发工具
	常用的开发Android应用的方法是免费Android开发套件(Android Software Development Kit(SDK))。这个开发套件与Eclipse一起使用，类似Android开发工具插件，还包含基于QEMU的模拟器，使用户
可以让开发者在他们的工作区上完成大部分的开发。因为通常在真正的设备上与在模拟器上运行有差异，开发者还经常想在挂到Google Play前在真正的设备上测试他们的app。有的软件出版商会在软件
发行前在数十台设备上测试他们app的极端情况。

	******在数百台设备上测试
			显然，软件发布方无法实现在每一种设备上都行测试，因此，一些公司已经行动起来，允许应用程序开发人员通过将应用程序上传到这些公司的网站来测试其在几百个设备上的运行情况。
			这些公司通常通过网站来让开发者将他们的app上传到他们的设备农场来进行测试。开发者会得到详细的失败的报告以及失败的设备数据的精确log。如果你需要这些功能，可以看看以下这些网站
		Apkudo(http://www.apkudo.com)、Bitbar’s Testdroid products(http://testdroid.com)、LessPainful(http://www.lesspainful.com)
			有趣的是，Apkudo同时提供服务允许你在他们的设备上测试他们常用的上百个发布版本程序以确定AOSP运行没有任何问题。
	即使你不打算在你的嵌入式Android设备上开发任何的应用，我也强烈的建议在你的工作区中建立开发环境。这将允许您使用基本测试应用程序来验证对AOSP所做的修改的影响。如果您计划扩展AOSP的
API并创建和分发自己的自定义SDK，这一点也将非常重要。
	为了建立一个开发环境，按照Google为SDK提供的说明或者看看Marko Gargenta的书《Learning Android》。

##客户端开发(Native Development)
	虽然大多数应用程序是使用我们刚才讨论的开发环境专门开发的,某些开发人员需要运行本机编译的代码.为此，Google已经提供了本地开发工具包(Native Development Kit(NDK))。
正如宣传的那样，这主要是针对游戏开发者需要从他们的游戏运行的设备中挤出最后一点的性能。因此，NDK中提供的API主要面向图形渲染和传感器输入检索。
例如，著名的的“愤怒的小鸟”游戏非常依赖于本机运行的代码。
	
	显然，NDK的另一个可能的用途是将现有的代码移植到Android。如果你在过去几年内开发了大量传统C代码(为其他移动设备创建应用程序的开发公司的常见情况),你没有必要使用java来重写。
相反的，你可以使用NDK为Android编译它，并使用一些Java代码打包，以使用SDK提供的更多Android特定功能。例如，Firefox浏览器在很大程度上依赖于NDK来在Android上运行一些旧的代码
	正如我建议的。NDK比较好的一点就是你可以和SDK一起编译，因此你的app可以使用一部分jave一部分c。也就是说，理解NDK使你仅访问Android API的非常有限的一部分是至关重要的。例如当前
没有API允许你从一个没有C语言的NDK编译包中发送一个intent，而在SDK中是使用java来代替实现的。通过NDK提供的API主要面向游戏开发。
	有时嵌入式系统开发人员转向Android，希望能通过NDK来实现平台级的工作。NDK中的‘Native’单词有时候可能会对这方面产生误导，因为使用NDk仍然受到Java应用开发者面对的限制和要求。
所以，作为一个嵌入式系统的开发人员，请记住，NDK对于应用程序开发人员运行可以从Java代码调用的本机代码很有用，除此之外，NDK对于你承担的工作没有任何用处。

###总体结构
	图2-1可能是目前这本书中最重要的一张图片，我建议你想办法标注它的位置，如果有不明白的地方可以经常回来参考一下。虽然它看起来很简单-在后续我们会逐渐丰富它，但它却为我们了解Android
中各个位块是如何组合在一起的。
	如果你是熟悉linux的开发人员，首先要打击你的就是这个超过了linux内核本身，there is little in that stack that resembles anything typically seen in the Linux or Unix world。
这里没有glibc，没有X window system，没有GTK、没有BusyBox、没有bash shell等等。许多Linux开发的老手会注意到Android开起来会比较陌生。虽然Android的栈从用户空间的空白处开始，
我们将在附录A中讨论如何使“传统”或“经典”Linux应用程序和实用程序与Android堆栈并存。
	让我们从图2-1中的底部开始往上更深入的了解Android结构的各个模块。当我们覆盖了所有的模块后，我们将通过系统的启动过程结束本章。

	




