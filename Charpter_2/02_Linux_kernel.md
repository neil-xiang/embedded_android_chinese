> 翻译：[Neil-xiang](https://github.com/Neil-xiang)
> 校对：

##linux内核
	linux内核是所有传统上被标记为‘Linux’的发布版本的核心，包括主流的发行版本如Ubuntu、Fedora、Debian。虽然都是从Linux Kernel Archives(http://kernel.org)上以'vanilla'内核的形式
提供的，大部分的发行商在发布给他们的客户之前都会添加上了他们修复问题和加强性能或定制化一些功能的一些改动。同样，Android也是一样，Android的开发人员会修改‘vanilla’内核以满足他
们的需求。
	从历史上来说，Android与标准的做法不同，然而，有几个客户功能显然与‘vanilla’内核中发现的有显著的不同。事实上，由Linux发行版提供的内核可以很容易地被kernel.org的内核所替代，对
其他发行版的组件几乎没有影响，Android的用户空间组件除非在Android化的(“Androidized”)内核上运行，否则根本不起作用。就像我在前面章节提到过的那样，直到最近，Android的内核都是从主线
内核分支出来的。我同时也提到的，现在的请款更有了很大的改善，很多运行在Android上的功能都能在主线内核上找到方法。

	**希望你在读这篇文章的时候，你可以直接从http://kernel.org获取一个内核，并在其上运行AOSP。这样能进步很大，然而，如果过去的嵌入式linux的历史只是一个前奏的话，以后你能得到的在你的
硬件上运行的最好的、最合适的能兼容Android的内核的代码主要来源于你使用的Soc的供应商。

	虽然讨论linux内核内部已经超出了这本书的范围，让我们来看看添加到内核中的主要的Android定制的(‘Androidisms’).你可以参考Robert Love的书Linux 内核开发第三版(《Linux Kernel Development》3rd edition)
和网站Linux每周新闻(Linux Weekly News(LWN)http://lwn.net)来得到更多信息。LWN包含了很多内核内部的重要文章并提供了最新的关于linux内核开发的新闻。
	
	请注意，下面的小段只覆盖了最重要的Android化改动(Androidisms).Android内核在标准内核上通常包含了数百个改动，通常提供设备专用驱动、修改以及增强功能。你可以使用git来详细的分析
http://android.googlesource.com上的一个内核和它相对应的主线内核。同时，请注意有一些android内核上的功能，比如PEME驱动是一个设备的专用驱动，不必在所有的Android设备上使用。

	**如果你想知道如何从头创建一个Android内核或者你被分配到这个任务，比如你作为Soc供应商，看一下Linaro的工程师Vishal Bhoj在2012发布的的博客‘Android化linux内核’
(Androidization of linux kernel(http://bit.ly/16e1k5l))。在这个帖子中Vishal解释了如何使用‘git rebase'命令来创建一个Android化的内核。如果你想了解‘git rebase'命令的更详细信息，可以参考’git在线文档‘
(online git documentation(https://git-scm.com/book/en/v2/Git-Branching-Rebasing)).
	**顺便说一下，Linaro的主要工作目标是帮助他的成员进行平台支持，维护Linus HEAD密切相关的Android化内核。如果想了解更多信息，可以参考网站(http://bit.ly/Z5yG1m).
	
##唤醒锁(Wakelocks)
	对所有的Androidism来说，这个是有最大的争议的，讨论主线内核的主题已经产生了接近2000封邮件，并且当时没有明确的方法来实现唤醒锁功能。直到2011的内核峰会，内核开发者同意将大部分的
Androidism合并到主线，并为改进唤醒锁机制做出努力，最终决定，创建一个比其他的内核开发社区更能被接受的等效机制。
	在2012的5月底，唤醒锁及提前挂起(early suspend)的等效机制被合并到主线内核中.早期的提前刮起机制被称为自动睡眠(autosleep),并且唤醒锁机制被称为EPOLLWAKEUP的新的epoll()标志代替。
因此API也与原始的Android团队添加的功能有了不同，但是实现的功能是一样的。在我写这本书的时候，希望新的AOSP版本能使用新的机制来代替旧的。
	为了理解唤醒锁是什么并且如何工作，我们首先要讨论在通用的linux中如何进行电源管理的(power management)。最常见的电源管理应用场景就是笔记本。当运行Linux的笔记本的盖子关闭时，通常
会进入’挂起(suspend)‘或’睡眠(sleep)‘模式。在那个模式下，系统的状态被保存在RAM中，其他的硬件被关掉。因此，笔记本使用小的电池就变得可能。当笔记本的盖子打开时，笔记本就被’唤醒(wakes up)‘
用户可以立即恢复使用。
	这种方法在笔记本和桌面设备上能很好的应用，但是却不能在手持设备等移动设备上使用。因此，Android开发团队设计出一种稍稍改变了一下规则的机制用在移动设备上，让系统在用户的要求下才进入
睡眠模式，Android化的(Androidized)内核竟可能快的立即休眠。并且为了避免在处理重要的事情或者app在等待用户输入过程中进入睡眠，唤醒锁被用来是系统保持唤醒状态。
	唤醒所和提前挂起功能事实上是建立在Linux现有的电源管理功能上的。但是，他们提出了一种全新的开发模式，因为应用程序和驱动开发人员在进行关键操作或等待用户输入时必须使用唤醒锁。通常app开
发人员没有必要直接使用唤醒锁，因为他们使用的抽象自动的处理需要的锁。然而当他们明确的请求唤醒所示也可以与电源管理服务进行通信。另一方面，驱动开发人员可以调用添加在内核中的原始唤醒锁
来请求和释放唤醒锁。然而，在驱动程序中使用唤醒锁的缺点是，不可能将该驱动程序推入主线内核，因为在主线中不支持唤醒锁。鉴于最近主线中包含了同样的功能，所以这不再是问题。
	**以下LWN文章更详细地描述了唤醒锁，并解释了它们包含在主线内核中的各种问题
		• Wakelocks and the embedded problem
		• From wakelocks to a real solution
		• Suspend block
		• Blocking suspend blockers
		• What comes after suspend blockers
		• An alternative to suspend blockers
		• KS2011: Patch review
		• Bringing Android closer to the mainline
		• Autosleep and wake locks
		• 3.5 merge window part 2
	
##低内存杀手(Low-Memory Killer)
	如前所述，Android的行为非常依赖于低内存条件(low-memory).因此内存溢出时很严重的。基于此，Android开发团队添加了一个附加的低内存杀手到内核中来替换之前内核中默认的内存溢出杀手(OOM killer).
Android的低内存杀死机制提供了在应用开发文档中描述的策略，即除掉长时间未使用的组件的进程，而不是高优先级。
	Android的低内存杀死机制是基于Linux中提供的内存溢出调整机制可以为不同的进程执行不同的OOM kill优先级。基本上，OOM调整允许用户空间来控制内核的OOM killing的一部分策略。OOM的调整参数范围
为-17~15，数字越大意味着如果系统内存不足，则相关联的进程优先被杀死。
	因此，Android根据运行的组件将不同的OOM调整级别归纳为不同类型的进程并且配置为自己低内存杀死机制的级别，为每个类别的进程提供不同的阈值。这有效地允许它抢占内核自己的OOM杀手的激活，
只有当达到给定阈值时，系统没有内存才能启动，而不是在系统内存不足时就启动。
	用户空间策略本身在启动时由init进程应用(参考 57页)，并在活动管理器服务运行时重新调整并部分实施，活动管理器作为系统服务的一部分。活动管理是最重要的系统服务之一，负责管理之前提出的组件
的生命周期。
	**如果您想获得有关内核的OOM杀手的更多信息以及Android如何构建的信息，可以参考LWN上的改进OOM killer(Taming the OOM killer(http://lwn.net/Articles/317814/))文章。
	在写这篇文章的时候，伴随着许多特定的Android驱动开发，Android的低内存杀死机制在内存状态树上已经可以找到。目前正在重写低内存条件的通用框架。看看发布到Linux内核邮件列表（LKML）和
linux-vmevent补丁的用户空间的低内存杀手守护程序，以了解目前进度。本质上，修改的目标是将关于在低内存条件下的决策过程移植到用户空间的后台程序(daemons)中。

	**Android和Linux的状态树
	在写这篇文章的时候，很多的Android上的驱动程序以及功能被合并到状态树上。这意味着他们任然可以在(http://kernel.org)提供的主线内核上被找到，这也意味着内核开发人员认为这些驱动程序
在被认为成熟到足以与内核树的其余部分中发现的“干净”驱动程序集合之前需要工作。
	更具体的说，很多Android驱动程序在内核的的目录清单(driver/staging/android)中可以找到.但是直到重新编写满足Linux官方驱动的标准后才会被放置到drivers目录下。
	如果你对状态树不熟悉，看看Greg Kroah-Hartman在2009发表的博客<Linux 状态树是什么>(http://www.kroah.com/log/linux/linux-staging-update.html)中描述的-“linux状态树(或者简称状态)是用来
控制由于各种技术原因现在还不能合并到linux内核书的单独的驱动和文件系统。它包含在linux内核树中使用户可以比以往更容易获得驱动，并提供一个地方，解决过去大多数树外驱动时有数百个不同的
下载地址的问题”。

##Binder
	Binder是类似于Windowns下COM的RPC/IPC机制。它的根源实际上可以追溯到在Be公司被Palm收购之前在BeOS中完成的工作。它继续在Palm中运行，这项工作的成果最终被公布为OpenBinder项目。虽然OpenBinder
作为一个独立的项目未能幸免，但是其中有几个重要的开发者比如Dianne Hackborn and Arve Hjønnevåg，最后却在Android开发团队中工作。

	因此Android的Binder机制受到之前工作的启发，但是Android的实现却不是来源于OpenBinder的代码。相反是在OpenBinder功能的一个子集上的全新开发。如果你想了解Binder机制的基础及设计理念，
OpenBinder文档(OpenBinder Documentation(http://www.angryredplanet.com/~hackbod/openbinder/))任然必须要详读，Dianne Hackborn的在LKML上(http://lkml.org/lkml/2009/6/25/3)解释了
Binder在Andriod上是如何使用的。
	本质上，Binder试图在经典操作系统之上提供远程对象调用功能。换句话说，Binder试图接受并超越经典操作系统，而不是重新设计传统的操作系统概念。因此，开发人员可以将远程服务作为对象处理，
而无需处理新的操作系统。因此，可以很容易的通过添加远程可调用对象来扩展系统的功能，而不是实现新的后台程序(daemons)来提供新的服务，通常在Unix中就是这种理念。因此，远程对象可以以任何语言实现，
并且可以与其他远程服务共享相同的进程空间或者具有其自己的单独进程。所需要的只是调用它的方法是他的接口定义及引用。
	如你们在图2-1中看到的那样，Binder作为Android框架的基础。它使app与系统服务通信，各个app之间的服务组件相互通信，尽管像我之前提到的那样，app开发人员实际上并没有直接和Binder通信。相反，
他们使用aidl工具产生的接口和存根进行通信。即使当一个app与由android.*之类的API抽象出来的系统服务进行交流时，开发者也绝对不能实际的看到Binder被使用。

	**虽然从语义上听起来很相似，但是通过第26页“组件”(components)中介绍的作为应用程序开发人员可用的组件之一的“服务”(service)组件模型，在系统服务器内部运行的服务和其他应用程序之间运行的
服务之间存在很大差异。最重要的是，服务组件受制于与其他组件相同的系统机制。因此，他们是生命周期管理的并且在与其所属应用程序相关联的特权沙箱中运行。服务运行于系统服务器中，另一方面，
通常运行在系统权限并且从boot到reboot阶段一直存在。这两个类型的服务唯一共享的东西是:a)他们的名字，b)使用Binder进行交流的用法。

	Binder机制的一部分系统内驱动可以通过/dev/binder目录查看，它通过调用ioctl()在通信的各方传输数据。它还允许一个进程将自己指定为一个“上下文管理器”("Context Manager")。上下文管理器的重
要性以及实际的用户空间使用Binder驱动程序将在本章后面更详细地讨论。

	自从linux内核3.3版本发布后，Binder驱动就已经合并到状态树中。目前没有任何项目正在清理此驱动程序或重写它，使其适用于和/或用于标准Linux桌面和服务器系统的通用应用中。因此在可预见的未来
会继续在driver/staging/android目录中。

##匿名分享内存(Anonymous Shared Memory(ashmem))
	在大多数操作系统中可用的另一种IPC机制是共享内存。在Linux中，作为系统V IPC机制的一部分，通常以POSIX SHM功能的形式提供。然而，如果你看AOSP中包含的bionic/libc/docs/SYSV-IPC.TXT文件
你会发现似乎Android开发团队对SysV IPC不满。实际上，在该文件中提出，在Linux中使用SysV IPC机制可能会导致内核中的资源泄漏，为恶意或行为不端的软件打开门槛，瘫痪系统。
	正如Android开发团队看到的那样，匿名分享内存似乎是由于Sys V IPC的缺点而存在的，尽管在使用中或者在匿名分享内存的代码文档中或者Android开发人员并没有说明。因此，匿名分享内存被描述为
与POSIX SHM相类似但具有不同的功能。比如说，当所有涉及他们的进程都推出后，被用来计算毁掉的内存块，并且如果系统需要内存，还可以压缩映射的内存块。”固定“的内存块不允许压缩，而“非固定”
的内存块允许被压缩。

	通常，第一个进程使用匿名分享内存创建一个共享内存区域，并使用Binder与其希望共享该区域的其他进程共享相应的文件描述符。例如，Dalvik的JIT代码缓存通过匿名分享内存提供给Dalvik实体。
许多的系统服务组件，比如Surce Flinger和Audio Flinger，通过Imemory接口依赖与匿名分享内存而不是直接使用。
	
	**IMemory是一个只在AOSP中提供的内部接口，不对app开发人员开放。和app开发人员接触最近的类(class)是Memory File。
	
	在写这本书的时候，匿名内存分享驱动已经包含在主线的drivers/staging/android/目录下，并打算重写。
	
	
##闹钟(Alarm)
	闹钟是默认的内核功能不满足Android的需求而添加一个驱动的另一个例子。Android的闹钟驱动事实上是在内核已经存在的实时时钟(Real-Time Clock(RTC))以及高分辨率时钟(High-Resolution 
Timers(HRT))功能基础上的.内核的RTC功能提供给驱动开发人员一个创建板级RTC功能的框架，而内核通过主RTC驱动程序提供了与硬件无关的单一接口。而高分辨率时钟允许调用者在非常精确的一
个时间点来唤醒。
	在‘vanilla’Linux中，应用程序开发人员通常会在给定的时间值到期时调用setitimer（）系统调用来得到一个信号；如果想要更多的信息，可以参考setitimer()的man页。系统调用允许一些类型
的定时器，其中之一就是ITIMER_REAL,使用了内核的HRT。然而，这些功能在系统刮起时无法使用。换句话说，如果一个应用使用setitimer()在一个指定的时间点来唤醒，但是在此过程中系统被挂起
了，那这个应用只有在设备被被再次唤醒时才能得到这个信号。
	与setitimer()的系统调用不同，内核的RTC驱动可以通过/dev/rtc并且允许用户使用inctl()来使用，此外，设置一个闹钟会由系统的RTC硬件驱动来激活。不管这个系统挂起与否，这个闹钟都会响应
，当他基于RTC的驱动以后，当系统从挂起状态重启时，此闹钟依然存在。
	Android的闹钟驱动聪明的结合了两个的优点，默认情况下，驱动使用系统的HRT功能来对用户提供闹钟功能，非常像嵌入在内核中的时钟功能。然而，如果系统将要挂起，它会对RTC进行编程，以便
系统在特定的时间被唤醒。所以，无论用户空间的应用合适需要精确的闹钟，它只需要使用Android的闹钟驱动在特定的时间被唤醒，而不用关心系统在中间是否有被挂起过。
	从用户空间来看，闹钟驱动看起来就像/dev/alarm中的特征装置并且允许用户通过ioctl()调用来设定一个闹钟和调整系统时间(wall time)。在/dev/alarm中有几个关键的AOSP组件。比如工具箱和
SystemClock类(class)，依靠app开发API来 设置/得到 系统时间。更重要的是，作为系统服务的一部分闹钟管理服务通过AlarmManager类(class)提供闹钟服务给app开发人员。
	驱动程序和报警管理器都会使用唤醒机制，以适当的方式来保持闹钟与Android的休眠相关的其余部分之间的一致性行为。因此，当一个闹钟被触发，在系统再次被挂起前，一个app有机会做它需要被
要求做的任何操作。
	在撰写本文时，Android的报警驱动程序位于内核的状态树(staging tree)中，上游工作正在等待。
	
##日志记录器(logger)
	日志记录器对于任何一个Linux系统都是内嵌在系统中另一个必要的组件。能够通过分析实时或事后的系统日志错误和警告来隔离致命错误，特别是瞬态问题。大多数发行版本的Linux系统都包括两个
日志记录器：内核自己的日志，通常通过'dmesg'来读取，通常以文件形式存放在/val/log目录中。内核日志通常包含内核代码和设备驱动在内核内部调用printk()输出来的各种信息。对他们来说，系统
日志中包含来自于系统中运行的各种后台程序(daemons).事实上，你可以使用'logger'命令来发送你自己的消息给系统日志。
	至于Android，内核日志记录也是同样的用法。然而在大多数的Linux的发行包中都没有找到常用的系统日志记录软件包。事实上，Android基于添加到内核中的日志记录器驱动定义了它自己的日志记录
规则。经典的系统日志依赖与通过端口来发送消息，因此产生一个任务切换。也可以使用文件来存储信息，所以产生了对存储设备的写操作。相比之下，Android的日志记录功能管理了一些单独的内核托
管缓冲区，用于记录来自用户空间的数据。因此，每个记录的事件都不需要任务切换或文件写入。相反，驱动程序在RAM中维护循环缓冲区，其中记录每个传入的事件并立即返回给调用者。
	在使用Android的设置中避免文件写入有许多好处。例如，不同于笔记本或者是服务器环境，不一定需要在嵌入式系统中无限期地增长的日志。即使所使用的文件系统类型可能是只读的，也希望有一个
满足日志记录需求的系统。此外，大部分的Android设备依赖与固态的存储设备，他存在着擦写寿命限制。在这些情况下，避免多余的写作是至关重要的。
	由于其轻巧，高效和友好的嵌入式系统设计，用户空间组件实际上可以在运行时使用Android记录器来定期记录事件。实际上，应用程序开发人员可以使用的Log类(class)或多或少的直接调用记录器驱
动来写入主事件缓冲区。显然，美好的事物总是被滥用，最好是保持日志记录操作轻巧的同时仍然能通过app的API来显示日志记录和AOSP内部的日志记录操作同样的使用等级，如果Android的日志记录是
基于syslog的，那么很可能很难保证能达到这个目的。
	图2-2更详细的描述了Android的日志记录操作的框架。你可以看到，日志记录器驱动是所有其他日志记录操作相关功能所依赖的核心构建块。每一个它管理的缓冲区(buffer)都在/dev/log/中有一个单
独的入口。然而，没有任何用户空间组件和它直接交互。而是依赖与liblog，它可以提供许多不同的日志记录功能。根据正在使用的功能和正在传递的参数，事件将被记录到不同的缓冲区。liblog功能通
常通过log和slog类来使用，例如，会用来测试事件是否是由无线模块发送的，如果是的话，事件会被送到‘radio’缓冲区；如果不是的话，事件会被送到主‘main’缓冲区，但是slog类会将事件送到系统
(system)缓冲区。主‘main’缓冲区是由logcat命令显示的没有任何参数的情况下发出的事件的缓冲区。
	Log和EventLog类(class)都通过应用开发API公开出来，但是Slog只在AOSP内部使用。尽管app开发人员可以使用EventLog，但是在文档中已经明确的被定义为系统集成商而不是app开发人员。事实上，作
为开发文档的一部分的代码例子都使用的Log类(class)。通常来说，EventLog通常被系统组件使用来记录二进制事件到Android的事件(Event)缓冲区。许多系统组件，特别是系统服务器托管服务(System 
Server-host services),会组合使用Log、Slog、EventLog来记录不同的事件。例如，一个和app开发人员有关系的事件可能使用Log来记录日志，而与平台开发人员或系统集成商相关的事件会使用Slog和EventLog
来记录日志。
	请注意，app开发人员经常用来转存Android日志的logcat实例也依赖于liblog。除了为日志记录器驱动提供存取操作外，liblog还提供规定格式的事件更好的打印和过滤。liblog的另一个特点是要求每一个
被日记记录的事件需要有优先级、标签和数据。优先级可以是完整信息(verbose)、调试信息(debug)、输出信息(info)、警告(warn)或错误(error)。标签式一个标识组件或模块写入日志的唯一的一个字符串。
而数据是要记录的日志的实际信息。事实上这样的描述对于任何熟悉app开发API的人来说听起来应该是相当熟悉的，因为这实际上是Log这个类(class)的开发人员文档中所阐述的。
	这里的最后一块难题时adb命令，正如我们稍后讨论的那样，AOSP包含一个运行在Android设备中的一个后台程序-Android调试桥接器(Android Debug Bridge(ADB))，它允许主机通过’adb‘命令行工具来访问
设备。当你在主机上敲入‘adb logcat’时，后台程序实际上就启动目标板上的‘logcat’命令并转存它的主‘mian’缓冲区并将数据传送回主机并在终端上显示出来。
	在写这本书的时候，日志记录器驱动已经合并到内核的/drivers/staging/android目录下了。如果想了解更多关于这个驱动主线的更多消息，可以参考’Android 日志记录器项目‘(Mainline Android logger 
project(http://elinux.org/Mainline_Android_logger_project)).

##其他值得注意的Androidisms
	除了已经涵盖的Androidism之外，还有其他一些即使我没有详细介绍的Androidism也值得注意。
	*Paranoid networking
	通常在Linux中，所有的进程都允许创建一个端口来和网络通信。然而，根据Android的安全模式，必须控制对网络功能的访问。所以，在内核中添加了一个选项来根据当前进程所属的特定的组或者某个进程的
特殊功能来管理端口创建和网络访问。这个在IPv4、IPv6和蓝牙中有所体现。
	在写这本书的时候，这个功能在没有合并到主线中，所以它的路径还不清楚。你可以在没有这个功能的内核上运行AOSP，但是Android的一些权限系统，特别是端口创建方面有可能会失效。
	*RAM控制台(RAM console)
	就像我之前提到的那样，内核管理它自己的日志，你可以通过'dmesg'命令读取它。这个日志的内容非常有用，通常包含驱动或者内核子系统的一些重要信息。在内核错误或崩溃的情况下，他的内容可以用来事
后验证和分析。由于这些信息通常在重新启动时丢失，Android添加了一个驱动，注册一个基于RAM的控制台，可以重新启动并使其内容可通过/proc/last_kmsg访问.
	在我写这本书的时候，RAM控制台的功能看来已经在pstorefilesystem目录/fs/pstore内被合并到主线中了。
	*物理内存(Physical memory(pmem))
	和匿名共享内存(ashmem)一样，物理内存(pmem)也允许进程间共享内存。然而，不同于匿名共享内存(ashmem)，物理内存(pmem)允许共享一大块物理上连续的内存空间，而不是虚拟内存。除此之外，这些内存区
域也可能在进程和驱动之间共享。例如，对于G1手机，物理内存(pmem)堆被用来进行2D的硬件加速。然而，请注意，物理内存(pmem)只能被极少数的几个设备使用。事实上，根据Android内核开发团队成员-Brian Swetland
所说，MSM7201A的限制特意写了特定的地址，MSM7201A是G1中的Soc。
	在写这本书的时候，物理内存驱动被认为是过时的而被淘汰了。在内核主线中已经找不到了，并且也没有计划要复活它。而看来ION 内存分配(ION memory allocator(https://lwn.net/Articles/480055/))已经
替换掉了所有曾经使用物理内存(pmem)的地方。


